# Mo Mit工作原理

## 简介

> Mo Mit区别于任何一种加密协议 比如shandowsocks obfs4 snowflake 等的单一混淆模式
>
> 它采用多混淆模式 比如这一分钟混淆成视频通话 下一分钟混淆成浏览视频等
>
> 而且采用Go语言(Golang)编写 性能很高 虽然比Rust性能还是要低一点点 但是胜在好学好写

## 编译

> MoMit分为客户端(MoMitClient)和服务端(MoMitServer),你可以在根目录找到这两个文件夹
>
> 第0步 需要先CD到根文件夹
>
> 首先说用Go build编译 
>
> 客户端:`cd ./MoMitClient` (先回车) 然后 `go build ./main.go ./utils.go` 
>
> 服务端:`cd ./MoMitServer` (先回车) 然后 `go build ./main.go ./utils.go`
>
> 用MakeFile编译
>
> 客户端:make client
>
> 服务端:make server
>
> 清理编译的二进制文件:make debuild
>
> 运行目录的build-all脚本

## 传输协议

> 代码表示IV1是几 就用什么协议传输

| 代码 | 协议           |
| ---- | -------------- |
| 1    | TCP RAW        |
| 2    | UDP 默认为QUIC |
| 3    | TLS            |
| 4    | HTTPS          |
| 5    | DoT            |
| 6    | DoH            |
| 7    | mKCP           |
| 8    | gRCP           |

## 伪装协议

> 代码IV2是几 就是什么伪装特征
>
> 而且还会添加一定的随机值 在数据包开始传输前就商量好在什么位置(可能会在一个数据包内多地方插入多个随机值)
>
> 更气死防火墙的是 每间隔一个随机值(最小为1 最大为20的整数) 这个代码还会随机生成一个新的 使代理服务器也伪装成反代 客户端伪装成利用这个反代上网 正常使用
>
> 还有TTL值伪装 让代理服务器看起来更像一个反代服务器
>
> 还有代理服务器IP自动轮换 每隔几分钟换一个代理服务器IP 气死DPI 而且还支持IPv6 更气死DPI
>
> 更气死DPI的是 这东西还会发送几个真真假假的数据包 他会真的创建一个访问网站的请求 但是到达代理服务器后就会被删除
>
> 如果某个IP对代理服务器重放数据包 他还会真的返回一个合法的页面(或者合法网站DNS查询结果)给这个IP 而且为了避免露馅 这个IP还会被记录 每一次重放都会返回一样的数据

| 代码 | 伪装特征           | 伪装行为                                                     |
| ---- | ------------------ | ------------------------------------------------------------ |
| 9    | 看视频网站         | 模拟CDN行为 将流量分成多个小片段 随机分布在不同IP上          |
| 10   | 听音乐网站         | 模拟缓冲与暂停 间歇性传输流量，而非持续传输                  |
| 11   | 下载大文件         | 模拟断点续传 间隔一段时间重新请求文件的不同部分              |
| 12   | 登录cloudflare网站 | 小数据包 间隔时间稍长 模拟登录一个网站                       |
| 13   | 玩网络游戏         | 高频小数据包 模拟UDP流量 结合Ping值随机化(但是也有个限度 最大500ms 最小100ms 而且波动稍小) |
| 14   | 视频通话           | 模拟WebRTC或Zoom等视频会议协议                               |
| 15   | 随机数据           | 用OBFS4+Shandowsocks先行伪装 然后插入几个无用数据            |

## 数据包加速

> Mo Mit采用多种先进的数据包体积缩小模式 用来保证数据包体积更小 传输的数据更多
>
> 1.前导码删除
>
> 2.帧间隙删除
>
> 3.尽可能尝试帧分片
>
> 4.如果协议基于TCP 还会开启BBR
>
> 5.如果协议基于UDP 还会开启UOT
>
> 6.启用头部压缩
>
> 7.启用服务端(到代理服务器)Gzip压缩和Brotli压缩
>
> 8.如果随机到了https 还会启用HTTP/3
>
> 9.合并相似数据
>
> 10.IPv4/v6自动选择最优
>
> 11.启用视频或图片压缩
>
> 还有更多

## 实际网际网路运行流程简化

> 首先客户端需要拿到服务器密钥和一个服务器信任列表
>
> 信任列表动态更新 一次最多10条 最少2条 可以是IPv4 IPv6单地址 优先推荐IPv6服务器搭建 毕竟地址多 而且是新协议 监管相对较少



> 1.通信代理服务器 与其建立WS连接
>
> 2.然后交换加密密钥 密钥会在本地自签  然后确认服务器就是你要连接的那一台 如果有中间人篡改则立即切断网络(kill swithy)
>
> 3.然后开始第二个数据包交换:首先本地生成一个随机值 一个IV1然后通报服务器
>
> 4.服务器拿到这个数值之后 向客户端发送一个已收到数据包 
>
> 5.在客户端收到数据包后切断WS连接
>
> 6.使用新协议开始传输数据
>
> 7.在新协议商议完毕后 开始商议随机数据位置 (IV3) 数字是几就添加几个随机包 最大10最小1的整数
>
> 8.客户端开始随机数据 并将TCP协议时商议好的加密密钥用作随机数据位置通报数据包的传输加密
>
> 9.服务端确认一切安好后 客户端开始随机IV2
>
> 10.IV2随机完毕后 向服务器加密数据后通报IV2是几
>
> 11.获取浏览器数据 开始使用Gzip和Brotli和视频压缩 压缩数据
>
> 12.开始前导码和帧间隙删除
>
> 13.删除完毕后开始合并和头部压缩数据
>
> 14.完成其他数据包优化工作
>
> 15.传输一个小型数据包通告服务器 这几分钟的传输模式
>
> 16.本地连接一个新IP地址
>
> 16.5.在境外通告使用的加密方式给下一个服务器(加密通告)
>
> 17.结束这台服务器的连接 开启一个新的连接 对着这个新地址开始连接
>
> 18.当随机的时间到期后就会切断跟这台服务器的连接 继续开启下一台服务器 如此循环



> 注意 在前几个数据包时都有加密 第一台服务器的所有数据均在加密环境下传输
>
> 而且在通告过程中的IV1伪装为DNS请求(比如 如果随机到了0 DNS结果返回为0.0.0.0) IV3伪装为加密的QUIC请求(比如看YouTube) IV2伪装为IMTP看邮件 第14步的小型数据包 伪装成加密的NTP请求 而且把值包裹在时间里面 外表看起来就像一个错误的时间 但...
>
> 而且这些请求如果面临重放攻击 一样可以获得保护
>
> 切换下一台数据服务器之前 客户端会先向这台服务器发送请求 内容大概是:你传完了吗(WS请求)
>
> 如果服务器说:我传完了 客户端就把他当成第一台服务器继续交换密钥
>
> 然后这台服务器在交换完毕密钥后 客户端再连接信任列表中的下一台服务器
